{"working":false,"featured":false,"private":false,"stars":[],"images":[],"categories":["5e7a80dd7c113618206df102","5e7a80dd7c113618206df0a6"],"publicCategories":["Generator"],"privateCategories":["fire"],"_id":"5e7a803f7c113618206dedb1","title":"GreatBallOfFire","rawFragmentSource":"/*{\n  \"CREDIT\": \"by mojovideotech\",\n  \"CATEGORIES\": [\n    \"generator\",\n    \"fire\"\n  ],\n  \"INPUTS\": [\n    {\n      \"NAME\": \"offset\",\n      \"TYPE\": \"point2D\",\n      \"MAX\": [\n        1,\n        1\n      ],\n      \"MIN\": [\n        -1,\n        -1\n      ]\n    },\n    {\n      \"NAME\": \"rotation\",\n      \"TYPE\": \"float\",\n      \"DEFAULT\": 0,\n      \"MIN\": -2,\n      \"MAX\": 2\n    },\n    {\n      \"NAME\": \"size\",\n      \"TYPE\": \"float\",\n      \"DEFAULT\": 2.5,\n      \"MIN\": 1,\n      \"MAX\": 4\n    },\n    {\n      \"NAME\": \"depth\",\n      \"TYPE\": \"float\",\n      \"DEFAULT\": 0.1,\n      \"MIN\": 0.03,\n      \"MAX\": 0.15\n    },\n    {\n      \"NAME\": \"density\",\n      \"TYPE\": \"float\",\n      \"DEFAULT\": 3.15,\n      \"MIN\": 0.1,\n      \"MAX\": 4\n    },\n    {\n      \"NAME\": \"rateX\",\n      \"TYPE\": \"float\",\n      \"DEFAULT\": 3,\n      \"MIN\": -9,\n      \"MAX\": 9\n    },\n    {\n      \"NAME\": \"rateY\",\n      \"TYPE\": \"float\",\n      \"DEFAULT\": 0.5,\n      \"MIN\": -9,\n      \"MAX\": 9\n    },\n    {\n      \"NAME\": \"rateZ\",\n      \"TYPE\": \"float\",\n      \"DEFAULT\": 1,\n      \"MIN\": -9,\n      \"MAX\": 9\n    }\n  ],\n  \"DESCRIPTION\": \"GreatBallOfFire\"\n}*/\n\n\n///////////////////////////////////////////\n// GreatBallOfFire  by mojovideotech\n//\n// based on :\n//\n// glslsandbox.com\\/e#30176.0\n// Fireball by @AlexWDunn\n//\n// Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n///////////////////////////////////////////\n\n#define saturate(oo) clamp(oo, 0.0, 1.0)\n#define MarchSteps 4\n#define Radius 1.5\n#define NoiseSteps 4\n#define Color1 vec4(1.0, 1.0, 1.0, 1.0)\n#define Color2 vec4(1.0, 0.8, 0.2, 1.0)\n#define Color3 vec4(1.0, 0.03, 0.0, 1.0)\n#define Color4 vec4(0.4, 0.02, 0.02, 1.0)\n\n\nvec3 mod196(vec3 x) { return x - floor(x * (1.0 / 196.0)) * 196.0; }\nvec4 mod196(vec4 x) { return x - floor(x * (1.0 / 196.0)) * 196.0; }\nvec4 permute(vec4 x) { return mod196(((x*56.0)+1.0)*x); }\nvec4 taylorInvSqrt(vec4 r){ return 1.79284291400159 - 0.85373472095314 * r; }\n\nfloat snoise(vec3 v)\n{\n\tconst vec2  C = vec2(1.0/6.0, 1.0/3.0);\n\tconst vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\n\n\tvec3 i  = floor(v + dot(v, C.yyy));\n\tvec3 x0 = v - i + dot(i, C.xxx);\n\tvec3 g = step(x0.yzx, x0.xyz);\n\tvec3 l = 1.0 - g;\n\tvec3 i1 = min(g.xyz, l.zxy);\n\tvec3 i2 = max(g.xyz, l.zxy);\n\tvec3 x1 = x0 - i1 + C.xxx;\n\tvec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y\n\tvec3 x3 = x0 - D.yyy;      // -1.0+3.0*C.x = -0.5 = -D.y\n \n \ti = mod196(i);\n\tvec4 p = permute( permute( permute( i.z + vec4(0.0, i1.z, i2.z, 1.0)) + i.y + vec4(0.0, i1.y, i2.y, 1.0 )) + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n\n\tfloat n_ = 0.142857142857;\n\tvec3  ns = n_ * D.wyz - D.xzx;\n\tvec4 j = p - 49.0 * floor(p * ns.z * ns.z);  \n\tvec4 x_ = floor(j * ns.z);\n\tvec4 y_ = floor(j - 7.0 * x_);    \n\tvec4 x = x_ *ns.x + ns.yyyy;\n\tvec4 y = y_ *ns.x + ns.yyyy;\n\tvec4 h = 1.0 - abs(x) - abs(y);\n\tvec4 b0 = vec4(x.xy, y.xy);\n\tvec4 b1 = vec4(x.zw, y.zw);\n\tvec4 s0 = floor(b0) * 2.0 + 1.0;\n\tvec4 s1 = floor(b1) * 2.0 + 1.0;\n\tvec4 sh = -step(h, vec4(0.0));\n\tvec4 a0 = b0.xzyw + s0.xzyw * sh.xxyy;\n\tvec4 a1 = b1.xzyw + s1.xzyw * sh.zzww;\n\tvec3 p0 = vec3(a0.xy, h.x);\n\tvec3 p1 = vec3(a0.zw, h.y);\n\tvec3 p2 = vec3(a1.xy, h.z);\n\tvec3 p3 = vec3(a1.zw, h.w);\n\n\tvec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n\tp0 *= norm.x;\n\tp1 *= norm.y;\n\tp2 *= norm.z;\n\tp3 *= norm.w;\n\tvec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n\tm = m * m;\n\n\treturn 35.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3)));\n}\n\nfloat Turbulence(vec3 position, float minFreq, float maxFreq, float qWidth)\n{\n\tfloat value = 0.0;\n\tfloat cutoff = clamp(0.5/qWidth, 0.0, maxFreq);\n\tfloat fade;\n\tfloat fOut = minFreq;\n\tfor(int i=NoiseSteps ; i>=0 ; i--)\n\t{\n\t\tif(fOut >= 0.5 * cutoff) break;\n\t\tfOut *= 2.0;\n\t\tvalue += abs(snoise(position * fOut))/fOut;\n\t}\n\tfade = clamp(2.0 * (cutoff-fOut)/cutoff, 0.0, 1.0);\n\tvalue += fade * abs(snoise(position * fOut))/fOut;\n\n\treturn 1.0-value;\n}\n\nfloat SphereDist(vec3 position)\n{\n\treturn length(position) - Radius;\n}\n\nvec4 Shade(float distance)\n{\n\tfloat c1 = saturate(distance*5.0 + 0.5);\n\tfloat c2 = saturate(distance*5.0);\n\tfloat c3 = saturate(distance*3.4 - 0.5);\n\t\n\tvec4 a = mix(Color1,Color2, c1);\n\tvec4 b = mix(a,     Color3, c2);\n\treturn \t mix(b,     Color4, c3);\n}\n\nfloat RenderScene(vec3 position, out float distance)\n{\n\tfloat noise = Turbulence(position * density + vec3(rateZ, rateX, rateY)*TIME, 0.1, 1.5, 0.03) * depth;\n\tnoise = saturate(abs(noise));\n\tdistance = SphereDist(position) - noise;\n\t\t\n\treturn noise;\n}\n\nvec4 March(vec3 rayOrigin, vec3 rayStep)\n{\n\tvec3 position = rayOrigin;\n\tfloat distance;\n\tfloat displacement;\n\tfor(int step = MarchSteps; step >=0  ; --step)\n\t{\n\t\tdisplacement = RenderScene(position, distance);\n\t\tif(distance < 0.05) break;\n\t\tposition += rayStep * distance;\n\t}\n\t\n\treturn mix(Shade(displacement), vec4(0.0, 0.0, 0.0, 0.0), float(distance >= 0.5));\n}\n\nbool IntersectSphere(vec3 ro, vec3 rd, vec3 pos, float radius, out vec3 intersectPoint)\n{\n\tvec3 relDistance = (ro - pos);\n\tfloat b = dot(relDistance, rd);\n\tfloat c = dot(relDistance, relDistance) - radius*radius;\n\tfloat d = b*b - c;\n\tintersectPoint = ro + rd*(-b - sqrt(d));\n\t\n\treturn d >= 0.0;\n}\n\nvoid main(void)\n{\n\tvec2 p = (gl_FragCoord.xy / RENDERSIZE.xy) * 2.0 - 1.0;\n\tp += offset;\n\tp.x *= RENDERSIZE.x/RENDERSIZE.y;\n\n\tfloat rotx = rotation* 4.0;\n\tfloat roty = -rotation * 4.0;\n\tfloat zoom = 16.0-(size*3.);\n\tvec3 ro = zoom * normalize(vec3(cos(roty), cos(rotx), sin(roty)));\n\tvec3 ww = normalize(vec3(0.0, 0.0, 0.0) - ro);\n\tvec3 uu = normalize(cross( vec3(0.0, 1.0, 0.0), ww));\n\tvec3 vv = normalize(cross(ww, uu));\n\tvec3 rd = normalize(p.x*uu + p.y*vv + 1.5*ww);\n\tvec4 col = vec4(0.0);\n\tvec3 origin;\n\tif(IntersectSphere(ro, rd, vec3(0.0), Radius + depth*7.0, origin))\n\t{\n\t\tcol = March(origin, rd);\n\t}\n\t\n\tgl_FragColor = col;\n}","rawVertexSource":"void main() {\n\tisf_vertShaderInit();\n}","thumbnailCloudinaryId":"vtk5lrwrmacsbouecjyt","description":"GreatBallOfFire","shaderType":"generator","oldId":"5576","createdAt":"2020-03-11T17:16:16.873Z","user":{"_id":"5e7a7f587c113618206ddda6","username":"atila9leon","name":"Atila Lopez de Aguileta","id":"5e7a7f587c113618206ddda6"},"username":"atila9leon","updatedAt":"2020-03-24T21:54:33.245Z","__v":0,"id":"5e7a803f7c113618206dedb1"}